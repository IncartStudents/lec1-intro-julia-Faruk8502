# Выболнить большую часть заданий ниже - привести примеры кода под каждым комментарием


#===========================================================================================
1. Переменные и константы, области видимости, cистема типов:
приведение к типам,
конкретные и абстрактные типы,
множественная диспетчеризация,
=#

# Что происходит с глобальной константой PI, о чем предупреждает интерпретатор?
const PI = 3.14159
PI = 3.14
#=
 Интерпретатор выведет предупреждение о том, что переопределение константы может вызвать
неожиданные последствия, но изменение все равно произойдёт (ошибки не будет)
=#

# Что происходит с типами глобальных переменных ниже, какого типа `c` и почему?
a = 1
b = 2.0
c = a + b
#=
- Julia видит, чтоя пытаюсь сложить Int64 и Float64
- По правилам promotion, Julia автоматически приводит Int64 к Float64 перед сложением, в 
в результате чего переменная c будет иметь тип Float64.
Это происходит потому, что тип Float "шире", то есть он может представить все значения
Int64, но не наоборот.
=#

# Что теперь произошло с переменной а? Как происходит биндинг имен в Julia?
a = "foo"
#= 
Изначально у нас было: a::Int64, далее тип переменной a поменялся на String.
Binding (связывание) в Julia происходит с помощью оператора присваивания "=". При его
использовании имя переменной связывается со указываемым значением.
=#

# Что происходит с глобальной переменной g и почему? Чем ограничен биндинг имен в Julia?
g::Int = 1
g = "hi"

function greet()
    g = "hello"
    println(g)
end
greet()
#=
- Сначала мы аннотируем переменную g (сразу определяем её тип)
- Далее пытаемся присвоить переменной g строку (появится ошибка, так как тип g был задан)
- В функциии создаётся новая локальная переменная g типа String, после чего выводится её 
значение
- При вызове функции (если исправить ошибку) выводится значение локальной переменной g
Чем ограничен binding в Julia:
    - Если мы объявляем аннотированные переменные
    - Областью видимости переменной
    - Если переменная - константа (появится предупреждение)
    - Если мы используем неизменяемые объекты (например кортежи)

=#
# Чем отличаются присвоение значений новому имени - и мутация значений?
v = [1,2,3]
z = v
v[1] = 3
v = "hello"
z
#=
Строка z = v привязывает имя z к тому же объекту (в данном случае вектору(массиву)), 
что и имя v. Теперь они оба ссылаются на один и тот же объект
Мутация - это изменение содержимого объекта (например, элемента массива):
v[1] = 3 
при этом, исходя из выше сказанного, данное изменение, произведенное через имя v
повлияет и на z. Таким образом, мутация не создаёт новый объект, а изменяет существующий

Присвоение же v = "hello" не мутируем старый объект, а создаёт новый, при этом имя z всё
также ссылается на старый массив.
=#

# Написать тип, параметризованный другим типом
#=
#=
1 - Простой параметризированный тип:
    struct Box{T}
        value::T
    end
    здесь T - это параметр типа (может быть Int, String, Vector и т.д.),
    value::T - поле, тип которого зависит от T.
2 - Ограничение параметра типа:
    struct NumericBox{T <: Number}
        value::T
    end
    здесь тип NumericBox принимает только числовые типы(Int, Float и т.д.)
3 - Параметризированный тип с несколькими параметрами:
    struct Pair{A, B}
        first::A
        second::B
    end
4 - Параметризированные изменяемые типы:
    mutable strict MutableBox{T}
        value::T
    end
    Особенностью данного параметризированного типа является наличие возможности изменить
    значение переменной данного типа, например:
    box = MutableBox(10)
    box.value = 20

=#
Написать функцию для двух аругментов, не указывая их тип,
и вторую функцию от двух аргментов с конкретными типами,
дать пример запуска
=#
#=
- Функция без указания типов:
    function f1(a, b)
        return a + b
    end
    принимает a и b любого типа, для которого определено сложение.
- Функция с указанием типов:
    function f2(a:Number, b::Number)
        return a + b
    end
    принимает только аргументы типа Number (Int, Float, Complex(комплексные числа)
    и т.д.).
#=
#=
Абстрактный тип - ключевое слово?
Примитивный тип - ключевое слово?
Композитный тип - ключевое слово?
=#
#=
- abstract type
- primitive type
- struct
разница между, например, обычным композитным типом:
    struct Point
        x :: Int64
        y :: Int64
и параметризированным абстрактным типом с жестко заданными типами полей:
    struct Point{X <: Int64, Y <: Int64}
        x :: X
        y :: Y
    end
заключается в том, что во втором случае поля x и y могут быть произвольными подтипами
типа Int64 (правда, не очень удачный пример, так как Int64 - уже конкретный тип). В 
первом же случае типы полей однозначно определены.
=#
#=
Написать один абстрактный тип и два его подтипа (1 и 2)
Написать функцию над абстрактным типом, и функцию над её подтипом-1
Выполнить функции над объектами подтипов 1 и 2 и объяснить результат
(функция выводит произвольный текст в консоль)
=#
- Создаём абстрактный тип:
    abstract type Shape end
- Создаём подтипы:
    struct Circle <: Shape
        side::Float64
    end

    struct Square <: Shape
        side::Float64
- Создаём функцию с аргуметом, имеющим созданный абстрактный тип:
    function describe1(shape::Shape)
        println("тип <Shape>")
    end
- Создаём функцию для подтипа:
    function describe2(circle::Circle)
        println("Радиус окружности", circle.radius")
    end
Объяснение результатов:
    - При вызове функции с абстрактным типом оба объекта принмаются и обрабатываются.
    - При вызове функции 1-го подтипа с аргументом 2-го подтипа возникает ошибка.
#===========================================================================================
2. Функции:
лямбды и обычные функции,
переменное количество аргументов,
именованные аргументы со значениями по умолчанию,
кортежи
=#

# Пример обычной функции

  function sum_of_squares(a, b)
    return a^2 + b^2
  end

# Пример лямбда-функции (аннонимной функции)

  double = x -> x * 2


# Пример функции с переменным количеством аргументов

   function summ_all(args...)
       total = 0
       for num in args
          total += num
       end
       return total
   end
# Пример функции с именованными аргументами

    function create_user(; name, age, is_admin=false)
         println("Создан пользователь $name, возраст $age", is_admin? " (админ)" : "")
     end

# Функции с переменным кол-вом именованных аргументов

     function configure_settingse(; args...)
          peintln("Настройки")
          for (key, value) in args
                println("$key = $value")
          end
      end

#=
Передать кортеж в функцию, которая принимает на вход несколько аргументов.
Присвоить кортеж результату функции, которая возвращает несколько аргументов.
Использовать splatting - деструктуризацию кортежа в набор аргументов.
=#
#=
1 - Передача кортежа в функцию, принимающую несколько аргументов:
       function(a, b, c)
          return a + b + c
        end

       my_tuple = (10, 20, 30)
       result = sum_three(my_tuple...) #Используем splatting

        println(result)
        При этом важно, чтобы размер кортежа равнялся количеству аргументов 
        вызываемой функции
2 - Присвоение кортежа результату функции, возрвращающей несколько значений
        function calculate_stats(x, y)
            sum = x + y
            product = x * y
            difference = x - y
            return sum, product, difference
        end

        stats_tuple = calculate_stats(8, 5)

        println(stats_tuple)
=#

#===========================================================================================
3. loop fusion, broadcast, filter, map, reduce, list comprehension
=#

#=
Перемножить все элементы массива
- через loop fusion и
- с помощью reduce
=#
#=
1 - через loop fusion:
          function loop(arg)
              result = 1
              for x in arg
                  result += x
              end
              return result
          end

          arg = [1, 2, 3, 4, 5]
          println(loop(arg))
2 - С помощью reduce:
          arg = [1, 2, 3, 4, 5]
          product = reduce((acc, x) -> acc * x, arg)
          println(product)
=#
#=
Написать функцию от одного аргумента и запустить ее по всем элементам массива
с помощью точки (broadcast)
c помощью map
c помощью list comprehension
указать, чем это лучше явного цикла?
=#

# Перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат


# В одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа


# Объяснить следующий код обработки массива names - что за number мы в итоге определили?
using Random
Random.seed!(123)
names = [rand('A':'Z') * '_' * rand('0':'9') * rand([".csv", ".bin"]) for _ in 1:100]
# ---
same_names = unique(map(y -> split(y, ".")[1], filter(x -> startswith(x, "A"), names)))
numbers = parse.(Int, map(x -> split(x, "_")[end], same_names))
numbers_sorted = sort(numbers)
number = findfirst(n -> !(n in numbers_sorted), 0:9)

# Упростить этот код обработки:


#===========================================================================================
4. Свой тип данных на общих интерфейсах
=#

#=
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
=#

#=
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
=#
abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")


# Аналогичные команды, но без наследования и в виде замыканий (лямбда-функций)


#===========================================================================================
5. Тесты: как проверять функции?
=#

# Написать тест для функции


#===========================================================================================
6. Дебаг: как отладить функцию по шагам?
=#

#=
Отладить функцию по шагам с помощью макроса @enter и точек останова
=#


#===========================================================================================
7. Профилировщик: как оценить производительность функции?
=#

#=
Оценить производительность функции с помощью макроса @profview,
и добавить в этот репозиторий файл со скриншотом flamechart'а
=#
function generate_data(len)
    vec1 = Any[]
    for k = 1:len
        r = randn(1,1)
        append!(vec1, r)
    end
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);


# Переписать функцию выше так, чтобы она выполнялась быстрее:


#===========================================================================================
8. Отличия от матлаба: приращение массива и предварительная аллокация?
=#

#=
Написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
=#

#=
Аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
=#

#=
Написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
=#


#===========================================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
=#


#=
Написать модуль с двумя функциями,
экспортировать одну из них,
воспользоваться обеими функциями вне модуля
=#
module Foo
    #export ?
end
# using .Foo ?
# import .Foo ?


#===========================================================================================
10. Зависимости, окружение и пакеты
=#

# Что такое environment, как задать его, как его поменять во время работы?

# Что такое пакет (package), как добавить новый пакет?

# Как начать разрабатывать чужой пакет?

#=
Как создать свой пакет?
(необязательно, эксперименты с PkgTemplates проводим вне этого репозитория)
=#


#===========================================================================================
11. Сохранение переменных в файл и чтение из файла.
Подключить пакеты JLD2, CSV.
=#

# Сохранить и загрузить произвольные обхекты в JLD2, сравнить их

# Сохранить и загрузить табличные объекты (массивы) в CSV, сравнить их


#===========================================================================================
12. Аргументы запуска Julia
=#

#=
Как задать окружение при запуске?
=#

#=
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl
б) из текста команды? (см. флаг -e)
=#

#=
После выполнения задания Boids запустить julia из командной строки,
передав в виде аргумента имя gif-файла для сохранения анимации
=#
